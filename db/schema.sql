------------------------------------------------
--                [EXTENSIONS]                --
------------------------------------------------
CREATE EXTENSION IF NOT EXISTS CITEXT;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS tablefunc;
CREATE EXTENSION IF NOT EXISTS "pgcrypto";


------------------------------------------------
--                   [ENUMS]                  --
------------------------------------------------
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'author_role_enum') THEN
        CREATE TYPE author_role_enum AS ENUM ('Author', 'Artist');
    END IF;
END$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'bug_type_enum') THEN
        CREATE TYPE bug_type_enum AS ENUM (
            'UI', 'Backend', 'Performance', 'Security', 'Database',
            'Network', 'Crash', 'Logic', 'Compatibility', 'Other'
        );
    END IF;
END$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'manga_status_enum') THEN
        CREATE TYPE manga_status_enum AS ENUM (
            'Ongoing', 'Completed', 'Hiatus', 'Cancelled',
            'Discontinued', 'One-shot', 'Upcoming'
        );
    END IF;
END$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'reading_status_enum') THEN
        CREATE TYPE reading_status_enum AS ENUM (
            'Reading', 'Completed', 'On Hold', 'Dropped',
            'Plan to Read', 'Rereading'
        );
    END IF;
END$$;


------------------------------------------------
--                  [SYSTEM]                  --
------------------------------------------------
CREATE TABLE IF NOT EXISTS app_infos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name CITEXT NOT NULL,
    value_str TEXT,
    value_int BIGINT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT app_infos_unique_cstr UNIQUE (name)
);


------------------------------------------------
--                   [USERS]                  --
------------------------------------------------
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username CITEXT UNIQUE NOT NULL,
    email CITEXT UNIQUE NOT NULL,
    p_hash BYTEA NOT NULL,
    perfil_image_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMPTZ,
    CONSTRAINT users_username_length CHECK ((length(username) <= 64))
);


------------------------------------------------
--                   [MANGAS]                 --
------------------------------------------------
CREATE TABLE IF NOT EXISTS mangas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title CITEXT NOT NULL,
    descr TEXT,
    cover_image_url TEXT NOT NULL,
    status manga_status_enum NOT NULL,
    color TEXT NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    mal_url TEXT,
    CONSTRAINT mangas_unique_title_cstr UNIQUE (title),
    CONSTRAINT mangas_descr_check CHECK (length(descr) <= 2048),
    CONSTRAINT mangas_title_check CHECK (length(title) <= 512)
);

CREATE TABLE IF NOT EXISTS manga_alt_titles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    manga_id BIGINT NOT NULL,
    title CITEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT manga_alt_titles_unique_alt_title UNIQUE (manga_id, title),
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON DELETE CASCADE ON UPDATE CASCADE
);


------------------------------------------------
--                   [AUTHORS]                --
------------------------------------------------
CREATE TABLE IF NOT EXISTS authors (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT authors_author_unique_name_cstr UNIQUE (name)
);


CREATE TABLE IF NOT EXISTS manga_authors (
    author_id BIGINT NOT NULL,
    manga_id BIGINT NOT NULL,
    role author_role_enum NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (author_id, manga_id, role),
    FOREIGN KEY (author_id) REFERENCES authors(id) ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON UPDATE CASCADE ON DELETE CASCADE

);


------------------------------------------------
--                   [GENRES]                 --
------------------------------------------------
CREATE TABLE IF NOT EXISTS genres (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    genre CITEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT genres_unique_genre_cstr UNIQUE (genre)
);

CREATE TABLE IF NOT EXISTS manga_genres (
    genre_id BIGINT NOT NULL,
    manga_id BIGINT NOT NULL,
    PRIMARY KEY (genre_id, manga_id),
    FOREIGN KEY (genre_id) REFERENCES genres(id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON DELETE CASCADE ON UPDATE CASCADE
);


------------------------------------------------
--               [CHAPTERS]                   --
------------------------------------------------
CREATE TABLE IF NOT EXISTS chapters (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    manga_id BIGINT NOT NULL,
    chapter_index INT NOT NULL,
    chapter_name TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chapters_unique_chapter_cstr UNIQUE (manga_id, chapter_index),
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON DELETE CASCADE ON UPDATE CASCADE
);


CREATE TABLE IF NOT EXISTS chapter_images (
    chapter_id BIGINT NOT NULL,
    image_index INT NOT NULL,
    image_url TEXT NOT NULL,
    width INT NOT NULL,
    height INT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (chapter_id, image_index),
    FOREIGN KEY (chapter_id) REFERENCES chapters(id) ON DELETE CASCADE ON UPDATE CASCADE
) PARTITION BY HASH (chapter_id);

-- partitions
CREATE TABLE IF NOT EXISTS chapter_images_p0 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 0);
CREATE TABLE IF NOT EXISTS chapter_images_p1 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 1);
CREATE TABLE IF NOT EXISTS chapter_images_p2 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 2);
CREATE TABLE IF NOT EXISTS chapter_images_p3 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 3);
CREATE TABLE IF NOT EXISTS chapter_images_p4 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 4);
CREATE TABLE IF NOT EXISTS chapter_images_p5 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 5);
CREATE TABLE IF NOT EXISTS chapter_images_p6 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 6);
CREATE TABLE IF NOT EXISTS chapter_images_p7 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 7);
CREATE TABLE IF NOT EXISTS chapter_images_p8 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 8);
CREATE TABLE IF NOT EXISTS chapter_images_p9 PARTITION OF chapter_images FOR VALUES WITH (MODULUS 10, REMAINDER 9);


------------------------------------------------
--              [USER INTERACTIONS]           --
------------------------------------------------
CREATE TABLE IF NOT EXISTS user_reading_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    manga_id BIGINT NOT NULL,
    user_id UUID NOT NULL,
    reading_status reading_status_enum NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ,
    CONSTRAINT user_reading_status_unique_status UNIQUE (manga_id, user_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS collections (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    descr TEXT,
    user_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT user_collections_title_cstr CHECK (length(title) < 64),
    CONSTRAINT user_collections_descr_cstr CHECK (length(descr) < 512),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS collections_mangas (
    collection_id BIGINT NOT NULL,
    manga_id BIGINT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (collection_id, manga_id),
    FOREIGN KEY (collection_id) REFERENCES collections(id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON DELETE CASCADE ON UPDATE CASCADE
);


------------------------------------------------
--                 [REPORTS]                  --
------------------------------------------------
CREATE TABLE IF NOT EXISTS bug_reports (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    descr TEXT,
    bug_type bug_type_enum NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT bug_reports_title_length CHECK (length(title) < 128),
    CONSTRAINT bug_reports_descr_length CHECK (length(descr) < 1024)
);

CREATE TABLE IF NOT EXISTS manga_requests (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    message TEXT,
    user_id UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT manga_requests_title_length_cstr CHECK (length(title) <= 128),
    CONSTRAINT manga_requests_message_length_cstr CHECK (length(message) < 256)
);

CREATE TABLE IF NOT EXISTS manga_blacklist (
    manga_id BIGINT PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (manga_id) REFERENCES mangas(id)
);


------------------------------------------------
--                 [METRICS]                  --
------------------------------------------------
CREATE TABLE IF NOT EXISTS user_metrics (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL,
    metric_date DATE NOT NULL DEFAULT CURRENT_DATE,
    total_logins INT DEFAULT 0,
    mangas_read INT DEFAULT 0,
    chapters_read INT DEFAULT 0,
    time_spent_seconds BIGINT DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT user_metrics_unique_cstr UNIQUE (user_id, metric_date),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS manga_metrics (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    manga_id BIGINT NOT NULL,
    metric_date DATE NOT NULL DEFAULT CURRENT_DATE,
    total_reads INT DEFAULT 0,
    unique_readers INT DEFAULT 0,
    total_chapters INT DEFAULT 0,
    total_collections INT DEFAULT 0,
    avg_reading_progress NUMERIC(5,2) DEFAULT 0.0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT manga_metrics_unique_cstr UNIQUE (manga_id, metric_date),
    FOREIGN KEY (manga_id) REFERENCES mangas(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS chapter_metrics (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    chapter_id BIGINT NOT NULL,
    metric_date DATE NOT NULL DEFAULT CURRENT_DATE,
    total_views INT DEFAULT 0,
    unique_readers INT DEFAULT 0,
    avg_read_time_seconds BIGINT DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chapter_metrics_unique_cstr UNIQUE (chapter_id, metric_date),
    FOREIGN KEY (chapter_id) REFERENCES chapters(id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS global_metrics (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_date DATE NOT NULL DEFAULT CURRENT_DATE,
    total_users BIGINT DEFAULT 0,
    active_users BIGINT DEFAULT 0,
    total_mangas BIGINT DEFAULT 0,
    total_chapters BIGINT DEFAULT 0,
    total_reads BIGINT DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT global_metrics_unique_cstr UNIQUE (metric_date)
);


------------------------------------------------
--                 [EVENTS]                   --
------------------------------------------------
CREATE TABLE IF NOT EXISTS user_events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID,
    event_type TEXT NOT NULL,
    entity_type TEXT,
    entity_id BIGINT,
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
);

------------------------------------------------
--                  [LOGS]                    --
------------------------------------------------

CREATE TABLE IF NOT EXISTS logs (
    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    level VARCHAR(50) NOT NULL,
    message TEXT NOT NULL,
    path TEXT,
    method VARCHAR(10),
    status_code INT,
    stacktrace TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    CONSTRAINT chk_log_level CHECK (level IN ('DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'))
);


------------------------------------------------
--               [TRIGGERS/FUNCTIONS]         --
------------------------------------------------
CREATE OR REPLACE FUNCTION update_chapter_metrics()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.event_type = 'chapter_read' AND NEW.entity_type = 'chapter') THEN
        INSERT INTO chapter_metrics (chapter_id, metric_date, total_views, unique_readers)
        VALUES (NEW.entity_id, CURRENT_DATE, 1, 1)
        ON CONFLICT (chapter_id, metric_date)
        DO UPDATE SET
            total_views = chapter_metrics.total_views + 1,
            unique_readers = chapter_metrics.unique_readers + 1;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_chapter_metrics
AFTER INSERT ON user_events
FOR EACH ROW
EXECUTE FUNCTION update_chapter_metrics();


CREATE OR REPLACE FUNCTION update_manga_metrics()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.event_type = 'manga_opened' AND NEW.entity_type = 'manga') THEN
        INSERT INTO manga_metrics (manga_id, metric_date, total_reads, unique_readers)
        VALUES (NEW.entity_id, CURRENT_DATE, 1, 1)
        ON CONFLICT (manga_id, metric_date)
        DO UPDATE SET
            total_reads = manga_metrics.total_reads + 1,
            unique_readers = manga_metrics.unique_readers + 1;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_manga_metrics
AFTER INSERT ON user_events
FOR EACH ROW
EXECUTE FUNCTION update_manga_metrics();


CREATE OR REPLACE FUNCTION update_user_metrics()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.event_type IN ('chapter_read', 'manga_opened')) THEN
        INSERT INTO user_metrics (user_id, metric_date, mangas_read, chapters_read, total_logins)
        VALUES (
            NEW.user_id,
            CURRENT_DATE,
            CASE WHEN NEW.event_type = 'manga_opened' THEN 1 ELSE 0 END,
            CASE WHEN NEW.event_type = 'chapter_read' THEN 1 ELSE 0 END,
            0
        )
        ON CONFLICT (user_id, metric_date)
        DO UPDATE SET
            mangas_read = user_metrics.mangas_read +
                CASE WHEN NEW.event_type = 'manga_opened' THEN 1 ELSE 0 END,
            chapters_read = user_metrics.chapters_read +
                CASE WHEN NEW.event_type = 'chapter_read' THEN 1 ELSE 0 END;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_user_metrics
AFTER INSERT ON user_events
FOR EACH ROW
EXECUTE FUNCTION update_user_metrics();


------------------------------------------------
--                   [VIEW]                   --
------------------------------------------------
CREATE OR REPLACE VIEW global_metrics_view AS
SELECT
    CURRENT_DATE AS metric_date,
    COUNT(DISTINCT u.id) AS total_users,
    COUNT(DISTINCT CASE WHEN u.last_login_at > NOW() - INTERVAL '7 days' THEN u.id END) AS active_users,
    COUNT(DISTINCT m.id) AS total_mangas,
    COUNT(DISTINCT c.id) AS total_chapters,
    COALESCE(SUM(mm.total_reads), 0) AS total_reads
FROM users u
LEFT JOIN mangas m ON TRUE
LEFT JOIN chapters c ON TRUE
LEFT JOIN manga_metrics mm ON mm.metric_date = CURRENT_DATE;


CREATE OR REPLACE FUNCTION persist_global_metrics()
RETURNS void AS $$
BEGIN
    INSERT INTO global_metrics (metric_date, total_users, active_users, total_mangas, total_chapters, total_reads)
    SELECT * FROM global_metrics_view
    ON CONFLICT (metric_date) DO UPDATE
    SET total_users = EXCLUDED.total_users,
        active_users = EXCLUDED.active_users,
        total_mangas = EXCLUDED.total_mangas,
        total_chapters = EXCLUDED.total_chapters,
        total_reads = EXCLUDED.total_reads;
END;
$$ LANGUAGE plpgsql;



------------------------------------------------
--                 [INDEXES]                  --
------------------------------------------------

-- USERS
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_users_last_login ON users(last_login_at DESC);

-- MANGAS
CREATE INDEX IF NOT EXISTS idx_mangas_title ON mangas(title);
CREATE INDEX IF NOT EXISTS idx_mangas_status ON mangas(status);
CREATE INDEX IF NOT EXISTS idx_mangas_created_at ON mangas(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_mangas_updated_at ON mangas(updated_at DESC);

-- MANGA_ALT_TITLES
CREATE INDEX IF NOT EXISTS idx_manga_alt_titles_manga_id ON manga_alt_titles(manga_id);
CREATE INDEX IF NOT EXISTS idx_manga_alt_titles_title ON manga_alt_titles(title);

-- AUTHORS
CREATE INDEX IF NOT EXISTS idx_authors_name ON authors(name);

-- AUTHOR_ROLES
CREATE INDEX IF NOT EXISTS idx_author_roles_manga_id ON author_roles(manga_id);
CREATE INDEX IF NOT EXISTS idx_author_roles_author_id ON author_roles(author_id);

-- LOGS
CREATE INDEX IF NOT EXISTS idx_logs_created_at ON logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_logs_level ON logs(level, created_at DESC);

-- GENRES
CREATE INDEX IF NOT EXISTS idx_genres_genre ON genres(genre);

-- MANGA_GENRES
CREATE INDEX IF NOT EXISTS idx_manga_genres_manga_id ON manga_genres(manga_id);
CREATE INDEX IF NOT EXISTS idx_manga_genres_genre_id ON manga_genres(genre_id);

-- CHAPTERS
CREATE INDEX IF NOT EXISTS idx_chapters_manga_id ON chapters(manga_id);
CREATE INDEX IF NOT EXISTS idx_chapters_manga_chapter ON chapters(manga_id, chapter_index);
CREATE INDEX IF NOT EXISTS idx_chapters_created_at ON chapters(created_at DESC);

-- CHAPTER_IMAGES (aplicado em cada partição)
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p0 ON chapter_images_p0(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p0 ON chapter_images_p0(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p1 ON chapter_images_p1(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p1 ON chapter_images_p1(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p2 ON chapter_images_p2(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p2 ON chapter_images_p2(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p3 ON chapter_images_p3(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p3 ON chapter_images_p3(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p4 ON chapter_images_p4(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p4 ON chapter_images_p4(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p5 ON chapter_images_p5(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p5 ON chapter_images_p5(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p6 ON chapter_images_p6(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p6 ON chapter_images_p6(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p7 ON chapter_images_p7(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p7 ON chapter_images_p7(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p8 ON chapter_images_p8(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p8 ON chapter_images_p8(chapter_id, image_index);

CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_id_p9 ON chapter_images_p9(chapter_id);
CREATE INDEX IF NOT EXISTS idx_chapter_images_chapter_idx_p9 ON chapter_images_p9(chapter_id, image_index);

-- USER_READING_STATUS
CREATE INDEX IF NOT EXISTS idx_user_reading_status_user_id ON user_reading_status(user_id);
CREATE INDEX IF NOT EXISTS idx_user_reading_status_manga_id ON user_reading_status(manga_id);
CREATE INDEX IF NOT EXISTS idx_user_reading_status_status ON user_reading_status(reading_status);
CREATE INDEX IF NOT EXISTS idx_user_reading_status_user_manga ON user_reading_status(user_id, manga_id);
CREATE INDEX IF NOT EXISTS idx_user_reading_status_updated ON user_reading_status(updated_at DESC) WHERE updated_at IS NOT NULL;

-- COLLECTIONS
CREATE INDEX IF NOT EXISTS idx_collections_user_id ON collections(user_id);
CREATE INDEX IF NOT EXISTS idx_collections_created_at ON collections(created_at DESC);

-- COLLECTIONS_MANGAS
CREATE INDEX IF NOT EXISTS idx_collections_mangas_manga_id ON collections_mangas(manga_id);
CREATE INDEX IF NOT EXISTS idx_collections_mangas_collection_id ON collections_mangas(collection_id);

-- BUG_REPORTS
CREATE INDEX IF NOT EXISTS idx_bug_reports_type ON bug_reports(bug_type);
CREATE INDEX IF NOT EXISTS idx_bug_reports_created_at ON bug_reports(created_at DESC);

-- MANGA_REQUESTS
CREATE INDEX IF NOT EXISTS idx_manga_requests_user_id ON manga_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_manga_requests_created_at ON manga_requests(created_at DESC);

-- USER_METRICS
CREATE INDEX IF NOT EXISTS idx_user_metrics_user_date ON user_metrics(user_id, metric_date DESC);
CREATE INDEX IF NOT EXISTS idx_user_metrics_date ON user_metrics(metric_date DESC);

-- MANGA_METRICS
CREATE INDEX IF NOT EXISTS idx_manga_metrics_manga_date ON manga_metrics(manga_id, metric_date DESC);
CREATE INDEX IF NOT EXISTS idx_manga_metrics_date ON manga_metrics(metric_date DESC);
CREATE INDEX IF NOT EXISTS idx_manga_metrics_total_reads ON manga_metrics(total_reads DESC);

-- CHAPTER_METRICS
CREATE INDEX IF NOT EXISTS idx_chapter_metrics_chapter_date ON chapter_metrics(chapter_id, metric_date DESC);
CREATE INDEX IF NOT EXISTS idx_chapter_metrics_date ON chapter_metrics(metric_date DESC);

-- GLOBAL_METRICS
CREATE INDEX IF NOT EXISTS idx_global_metrics_date ON global_metrics(metric_date DESC);

-- USER_EVENTS (CRÍTICO para performance dos triggers)
CREATE INDEX IF NOT EXISTS idx_user_events_user_id ON user_events(user_id);
CREATE INDEX IF NOT EXISTS idx_user_events_entity ON user_events(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_user_events_type ON user_events(event_type);
CREATE INDEX IF NOT EXISTS idx_user_events_created_at ON user_events(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_user_events_user_created ON user_events(user_id, created_at DESC);

-- Índices compostos para queries comuns
CREATE INDEX IF NOT EXISTS idx_user_events_chapter_read 
ON user_events(entity_id, created_at DESC) 
WHERE event_type = 'chapter_read' AND entity_type = 'chapter';

CREATE INDEX IF NOT EXISTS idx_user_events_manga_opened 
ON user_events(entity_id, created_at DESC) 
WHERE event_type = 'manga_opened' AND entity_type = 'manga';

-- Índice GIN para busca em metadata JSONB
CREATE INDEX IF NOT EXISTS idx_user_events_metadata ON user_events USING GIN(metadata);

-- APP_INFOS
CREATE INDEX IF NOT EXISTS idx_app_infos_name ON app_infos(name);


------------------------------------------------
--           [ÍNDICES FULL-TEXT SEARCH]       --
------------------------------------------------

-- Para busca eficiente de mangás por título e descrição
CREATE INDEX IF NOT EXISTS idx_mangas_title_trgm ON mangas USING gin(title gin_trgm_ops);
CREATE INDEX IF NOT EXISTS idx_mangas_descr_trgm ON mangas USING gin(descr gin_trgm_ops);

-- Para busca de autores
CREATE INDEX IF NOT EXISTS idx_authors_name_trgm ON authors USING gin(name gin_trgm_ops);